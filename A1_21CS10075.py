# -*- coding: utf-8 -*-
"""comp_Bio.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BRcNWqpeS8IP6KcnywJybcPAp-noBAlW
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install Bio

import os
import requests
import subprocess

def download_pdb_files(pdb_id):
    pdb_id = pdb_id.lower()  # Ensure lowercase for consistency
    pdb_url = f'https://files.rcsb.org/download/{pdb_id}.pdb'
    fasta_url = f"https://www.rcsb.org/fasta/entry/{pdb_id}"

    pdb_filename = f'{pdb_id}.pdb'
    fasta_filename = f'{pdb_id}.fasta'

    # Download PDB file
    print(f'Downloading PDB file for {pdb_id}...')
    pdb_response = requests.get(pdb_url)
    if pdb_response.status_code == 200:
        with open(pdb_filename, 'w') as pdb_file:
            pdb_file.write(pdb_response.text)
        print(f'PDB file saved as {pdb_filename}')
    else:
        print(f'Failed to download PDB file for {pdb_id}')

    # Download FASTA file
    print(f'Downloading FASTA file for {pdb_id}...')
    fasta_response = requests.get(fasta_url)
    if fasta_response.status_code == 200:
        with open(fasta_filename, 'w') as fasta_file:
            fasta_file.write(fasta_response.text)
        print(f'FASTA file saved as {fasta_filename}')
    else:
        print(f'Failed to download FASTA file for {pdb_id}')

    return pdb_filename, fasta_filename

#pdb_file,fasta_file = download_pdb_files("4HHB")

from Bio import PDB, SeqIO

def extract_sequence_from_pdb(pdb_file):
    """Extracts chain-wise protein sequences from a PDB file."""
    parser = PDB.PDBParser(QUIET=True)
    structure = parser.get_structure("protein", pdb_file)

    sequences = {}
    three_to_one = {
        'ALA': 'A', 'ARG': 'R', 'ASN': 'N', 'ASP': 'D', 'CYS': 'C',
        'GLN': 'Q', 'GLU': 'E', 'GLY': 'G', 'HIS': 'H', 'ILE': 'I',
        'LEU': 'L', 'LYS': 'K', 'MET': 'M', 'PHE': 'F', 'PRO': 'P',
        'SER': 'S', 'THR': 'T', 'TRP': 'W', 'TYR': 'Y', 'VAL': 'V'
    }

    for model in structure:
        for chain in model:
            seq = []
            for residue in chain:
                if residue.get_resname() in three_to_one:
                    seq.append(three_to_one[residue.get_resname()])
            sequences[chain.id] = "".join(seq)

    return sequences  

def extract_sequence_from_fasta(fasta_file):
    """Extracts chain-wise sequences from a FASTA file."""
    fasta_sequences = {}
    with open(fasta_file, "r") as fasta:
        for record in SeqIO.parse(fasta, "fasta"):
            
            chain_id = record.id.split(":")[-1] if ":" in record.id else "A"  
            fasta_sequences[chain_id] = str(record.seq)

    return fasta_sequences  


def compare_sequences(pdb_sequences, fasta_sequences):
    """Compares each PDB chain with all FASTA chains."""
    for pdb_chain_id, pdb_seq in pdb_sequences.items():
        print(f"\nðŸ”¹ **Comparing PDB Chain {pdb_chain_id} with all FASTA chains...**")

        for fasta_chain_id, fasta_seq in fasta_sequences.items():
            print(f"\n  ðŸ”¸ **Comparing with FASTA {fasta_chain_id}...**")

            if pdb_seq == fasta_seq:
                print(f" Match found! PDB Chain {pdb_chain_id} matches FASTA {fasta_chain_id} exactly.")
            else:
                print(f" Mismatch detected between PDB Chain {pdb_chain_id} and FASTA {fasta_chain_id}.")

                # Print mismatch positions
                for i, (pdb_res, fasta_res) in enumerate(zip(pdb_seq, fasta_seq)):
                    if pdb_res != fasta_res:
                        print(f"   - Mismatch at position {i+1}: PDB({pdb_res}) â‰  FASTA({fasta_res})")

                # Report length differences
                if len(pdb_seq) != len(fasta_seq):
                    print(f"   - Length difference: PDB({len(pdb_seq)}) vs FASTA({len(fasta_seq)})")



def count_chains(pdb_sequences):
    print(f"Number of chains in the protein structure: {len(pdb_sequences)}")

def detect_chain_breaks(pdb_sequences, fasta_sequences):
    
    for pdb_chain_id, pdb_seq in pdb_sequences.items():
        print(f"\n RUNNING CHECK OF PDB chain {pdb_chain_id} against all FASTA sequences:")

        for fasta_chain_id, fasta_seq in fasta_sequences.items():
            print(f" Comparison with FASTA chain {fasta_chain_id}")

            if pdb_seq == fasta_seq:
                print(f"  No chain breaks between PDB {pdb_chain_id} and FASTA {fasta_chain_id}.")
            else:
                print(f"  Chain breaks detected between PDB {pdb_chain_id} and FASTA {fasta_chain_id}!")
                for i, (pdb_res, fasta_res) in enumerate(zip(pdb_seq, fasta_seq)):
                    if pdb_res != fasta_res:
                        print(f" Mismatches found at position {i+1}: PDB={pdb_res} | FASTA={fasta_res}")

#find_chain_breaks(pdb_sequences, fasta_sequences)

def run_naccess(pdb_file):
    subprocess.run(["csh", "naccess", pdb_file], 
                   stdout=subprocess.PIPE,
                   stderr=subprocess.PIPE,
                   timeout=30  # Set a timeout to prevent hanging
                )
    rsa_file = pdb_file.replace(".pdb", ".rsa")
    return rsa_file if os.path.exists(rsa_file) else None

def parse_naccess_output(rsa_file):
    asa_values = {}
    with open(rsa_file, 'r') as f:
        for line in f:
            if line.startswith("RES"):
                cols = line.split()
                chain_id = cols[2]
                asa = float(cols[4])
                if chain_id not in asa_values:
                    asa_values[chain_id] = 0.0
                asa_values[chain_id] += asa
    return asa_values

def compute_molecular_weight(sequence):
    aa_weights = {
        'A': 89.1, 'R': 174.2, 'N': 132.1, 'D': 133.1, 'C': 121.2,
        'E': 147.1, 'Q': 146.2, 'G': 75.1, 'H': 155.2, 'I': 131.2,
        'L': 131.2, 'K': 146.2, 'M': 149.2, 'F': 165.2, 'P': 115.1,
        'S': 105.1, 'T': 119.1, 'W': 204.2, 'Y': 181.2, 'V': 117.1
    }
    return sum(aa_weights.get(aa, 0) for aa in sequence)

def write_output(pdb_id, pdb_sequences, asa_values):
    output_file = f"A1_{pdb_id}.txt"
    with open(output_file, "w") as f:
        for chain_id, sequence in pdb_sequences.items():
            num_residues = len(sequence)
            mol_weight = compute_molecular_weight(sequence)
            asa = asa_values.get(chain_id, 0.0)
            f.write(f"{chain_id} {num_residues} {mol_weight:.2f} {asa:.2f}\n")
    print(f"Results written to {output_file}")

if __name__ == "__main__":
    pdb_id = input("Enter PDB ID: ").strip().upper()
    pdb_file, fasta_file = download_pdb_files(pdb_id)

    if pdb_file and fasta_file:
        pdb_sequences = extract_sequence_from_pdb(pdb_file)
        fasta_sequence = extract_sequence_from_fasta(fasta_file)
        count_chains(pdb_sequences)
        detect_chain_breaks(pdb_sequences, fasta_sequence)

        rsa_file = run_naccess(pdb_file)
        if rsa_file:
            asa_values = parse_naccess_output(rsa_file)
            write_output(pdb_id, pdb_sequences, asa_values)
        else:
            print("NACCESS analysis failed.")